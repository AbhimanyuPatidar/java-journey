# Java Virtual Machine and its architecture

1. JVM runs Java applications as a run-time engine. JVM is the one that calls the main method present in a Java code.
2. JVM is a part of Java Runtime Environment (JRE).
3. JVM components are:
    1. **Class Loader Subsystem**  
        > a. **Loading**
        - Reads the “.class” file, generate the corresponding binary data and save it in the method area.  
        - For each “.class” file, JVM stores the following information in the method area:
            - The fully qualified name of the loaded class and its immediate parent class.
            - Whether the “.class” file is related to Class or Interface or Enum.
            - Modifier, Variables and Method information etc.
        - After loading the .class file, JVM creates an object of Class to represent this file in Heap memory
        - Methods of this Class are:
            - .getClass()
            - .getName()
            - .getDeclaredMethods()
        
        > b. **Linking**  
        Performs verification, preparation, and (optionally) resolution.
        - *Verification*: It ensures the correctness of the .class file i.e. it checks whether this file is properly formatted and generated by a valid compiler or not. If verification fails, we get run-time exception java.lang.VerifyError. This activity is done by the component **ByteCodeVerifier**. Once this activity is completed then the class file is ready for compilation.
        - *Preparation*: JVM allocates memory for class static variables and initializing the memory to default values. 
        - *Resolution*: It is the process of replacing symbolic references from the type with direct references. It is done by searching into the method area to locate the referenced entity.

        > c. **Initialization**  
        All static variables are assigned with their values defined in the code and static block(if any).  
        
    2. **Types of class loaders**:
        > a. **Bootstrap class loader**: Every JVM implementation must have a bootstrap class loader, capable of loading trusted classes. It loads core java API classes present in the “JAVA_HOME/lib” directory. This path is popularly known as the bootstrap path. It is implemented in native languages like C, C++.
        
        > b. **Extension class loader**: It is a child of the bootstrap class loader. It loads the classes present in the extensions directories “JAVA_HOME/jre/lib/ext”(Extension path) or any other directory specified by the java.ext.dirs system property. It is implemented in java by the sun.misc.Launcher$ExtClassLoader class.
        
        > c. **System/Application class loader**: It is a child of the extension class loader. It is responsible to load classes from the application classpath. It internally uses Environment Variable which mapped to java.class.path. It is also implemented in Java by the sun.misc.Launcher$AppClassLoader class.
        - Use .getClassLoader() method to find the Class Loader FileSystem.

    3. **JVM Memory Areas**:
        > a. **Method Area**:  
        All class level information like name, methods and variables (including static fields) stored here. Only one allowed per JVM.
        
        > b. **Heap Area**:  
        Information of all objects stored here. Only one allowed per JVM.
        
        > c. **Stack Area**:
        Created for every thread, stackframe/activation records stores method calls. Local variables are stored in corresponding frame. Destroyed after thread terminates.

        > d. **PC Registers**:
        Stores address of next intruction to be executed by thread. Created for every thread.

        > e. **Native Method stack**:
        Created for every thread, stores native method information.

    4. **Execution Engine**:
        Components are:
        > a. **Interpreter**:
        Interprets the bytecode, then executes. The disadvantage here is that when one method is called multiple times, every time interpretation is required.

        > b. **Just-In-Time Compiler(JIT)**:
        Used to increase the efficiency of an interpreter. It compiles the entire bytecode and changes it to native code so whenever the interpreter sees repeated method calls, JIT provides direct native code for that part so re-interpretation is not required, thus efficiency is improved.

        > c. **Garbage Collector**:
        It destroys un-referenced objects.

    5. **Java Native Interface (JNI)**:
        > Interacts with the Native Method Libraries and provides the native libraries(C, C++) required for the execution. It enables JVM to call C/C++ libraries and to be called by C/C++ libraries which may be specific to hardware.

    6. **Native Method Libraries**:
        > Collections of native libraries required for executing native methods. They include libraries written in languages like C and C++.